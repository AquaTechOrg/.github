# This workflow synchronizes iterations between parent issues and their sub-issues
name: Sync Sub-Issue Iterations
on:
  schedule:
    # Runs every 5 minutes to check for iteration changes
    - cron: '*/5 * * * *'
  workflow_dispatch: # Allows manual triggering for testing
  issues:
    types: [edited] # Trigger when issues are edited (including iteration changes)
jobs:
  sync_iterations:
    runs-on: ubuntu-latest
    steps:
      - name: Get project data and iteration field
        env:
          GH_TOKEN: ${{ secrets.TEST }}
          ORGANIZATION: AquaTechOrg
          PROJECT_NUMBER: 6
        run: |
          # Query project data including iteration fields
          gh api graphql -f query='
            query($org: String!, $number: Int!) {
              organization(login: $org){
                projectV2(number: $number) {
                  id
                  fields(first:50) {
                    nodes {
                      ... on ProjectV2Field {
                        id
                        name
                        dataType
                      }
                      ... on ProjectV2SingleSelectField {
                        id
                        name
                        dataType
                        options {
                          id
                          name
                        }
                      }
                      ... on ProjectV2IterationField {
                        id
                        name
                        dataType
                        configuration {
                          iterations {
                            id
                            title
                            startDate
                            duration
                          }
                        }
                      }
                    }
                  }
                }
              }
            }' -f org=$ORGANIZATION -F number=$PROJECT_NUMBER > project_data.json

          # Parse and store field IDs
          echo 'PROJECT_ID='$(jq -r '.data.organization.projectV2.id' project_data.json) >> $GITHUB_ENV
          echo 'ITERATION_FIELD_ID='$(jq -r '.data.organization.projectV2.fields.nodes[] | select(.name== "Iteration") | .id' project_data.json) >> $GITHUB_ENV

      - name: Get all project items with iterations
        env:
          GH_TOKEN: ${{ secrets.TEST }}
        run: |
          # Get all items in the project with their iteration values
          gh api graphql -f query='
            query($projectId: ID!) {
              node(id: $projectId) {
                ... on ProjectV2 {
                  items(first: 100) {
                    nodes {
                      id
                      content {
                        ... on Issue {
                          id
                          number
                          title
                          repository {
                            name
                            owner {
                              login
                            }
                          }
                        }
                      }
                      fieldValues(first: 20) {
                        nodes {
                          ... on ProjectV2ItemFieldIterationValue {
                            field {
                              ... on ProjectV2IterationField {
                                id
                                name
                              }
                            }
                            iterationId
                            title
                          }
                        }
                      }
                    }
                  }
                }
              }
            }' -f projectId=$PROJECT_ID > project_items.json

      - name: Get issue relationships for all project issues
        env:
          GH_TOKEN: ${{ secrets.TEST }}
        run: |
          echo "=== DISCOVERING ISSUE RELATIONSHIPS ==="
          
          # Extract all issues from the project
          echo "Getting relationships for all issues in project..."
          
          # Create a script to get sub-issue relationships
          cat > get_relationships.py << 'EOF'
          import json
          import subprocess
          import sys
          
          def run_command(cmd):
              try:
                  result = subprocess.run(cmd, shell=True, capture_output=True, text=True, check=True)
                  return result.stdout.strip()
              except subprocess.CalledProcessError as e:
                  print(f"Error running: {cmd}")
                  print(f"Error: {e.stderr}")
                  return None
          
          # Load project items
          with open('project_items.json', 'r') as f:
              project_data = json.load(f)
          
          all_relationships = {}
          
          items = project_data['data']['node']['items']['nodes']
          for item in items:
              content = item.get('content')
              if not content or not content.get('number'):
                  continue
                  
              repo_info = content['repository']
              repo_name = f"{repo_info['owner']['login']}/{repo_info['name']}"
              issue_number = content['number']
              
              print(f"Checking relationships for {repo_name}#{issue_number}")
              
              # Get issue details including timeline for sub-issue events
              cmd = f'''gh api repos/{repo_name}/issues/{issue_number}/timeline --paginate'''
              timeline_result = run_command(cmd)
              
              if timeline_result:
                  try:
                      timeline = json.loads(timeline_result)
                      
                      # Look for sub-issue relationships in timeline
                      sub_issues = []
                      parent_issues = []
                      
                      for event in timeline:
                          if event.get('event') == 'converted_to_draft':
                              continue
                          elif event.get('event') == 'connected':
                              # Issue was connected to another issue
                              if 'subject' in event:
                                  subject = event['subject']
                                  if subject.get('type') == 'issue':
                                      connected_repo = subject.get('repository', {}).get('full_name', repo_name)
                                      connected_number = subject.get('number')
                                      print(f"  Connected to {connected_repo}#{connected_number}")
                          elif event.get('event') == 'disconnected':
                              # Issue was disconnected from another issue  
                              if 'subject' in event:
                                  subject = event['subject']
                                  if subject.get('type') == 'issue':
                                      connected_repo = subject.get('repository', {}).get('full_name', repo_name)
                                      connected_number = subject.get('number')
                                      print(f"  Disconnected from {connected_repo}#{connected_number}")
                      
                      # Also try direct API for issue relationships if available
                      try:
                          # Try to get sub-issues using the newer API (beta feature)
                          sub_cmd = f'''gh api graphql -f query='query {{ repository(owner: "{repo_info['owner']['login']}", name: "{repo_info['name']}") {{ issue(number: {issue_number}) {{ id number title }} }} }}' '''
                          sub_result = run_command(sub_cmd)
                          print(f"  Issue details retrieved")
                      except:
                          pass
                          
                  except json.JSONDecodeError:
                      print(f"  Could not parse timeline for {repo_name}#{issue_number}")
              
              all_relationships[f"{repo_name}#{issue_number}"] = {
                  'sub_issues': [],
                  'parent_issues': []
              }
          
          # Save relationships
          with open('issue_relationships.json', 'w') as f:
              json.dump(all_relationships, f, indent=2)
              
          print(f"Processed {len(all_relationships)} issues")
          EOF
          
          python3 get_relationships.py

      - name: Analyze project content
        env:
          GH_TOKEN: ${{ secrets.TEST }}
        run: |
          echo "=== PROJECT CONTENT ANALYSIS ==="
          echo "Issues in Project #6 by repository:"
          jq -r '.data.node.items.nodes[].content | select(.repository != null) | "\(.repository.owner.login)/\(.repository.name)#\(.number): \(.title)"' project_items.json | sort || echo "No issues found in project"
          
          echo ""
          echo "Total issues in project:"
          jq '.data.node.items.nodes | length' project_items.json
          
          echo "Issues with content:"
          jq '[.data.node.items.nodes[] | select(.content != null)] | length' project_items.json

      - name: Debug project data
        run: |
          echo "=== PROJECT DATA DEBUG ==="
          echo "Project items structure:"
          jq '.data.node.items.nodes | length' project_items.json
          echo "First item:"
          jq '.data.node.items.nodes[0]' project_items.json
          echo "Items with content:"
          jq '[.data.node.items.nodes[] | select(.content != null)] | length' project_items.json

      - name: Debug issue content before analysis
        env:
          GH_TOKEN: ${{ secrets.TEST }}
        run: |
          echo "=== ISSUE CONTENT DEBUG ==="
          echo "Issue #1 full content:"
          gh api repos/AquaTechOrg/.github/issues/1 | jq '{number, title, body}'
          echo ""
          echo "Issue #2 full content:"
          gh api repos/AquaTechOrg/.github/issues/2 | jq '{number, title, body}'

      - name: Find parent-child relationships and sync iterations
        env:
          GH_TOKEN: ${{ secrets.TEST }}
        run: |
          # Create a script to process parent-child relationships and sync iterations
          cat > sync_script.py << 'EOF'
          import json
          import re
          import subprocess
          import sys
          import os

          def run_gh_command(cmd):
              """Run a GitHub CLI command and return the result"""
              try:
                  result = subprocess.run(cmd, shell=True, capture_output=True, text=True, check=True)
                  return result.stdout.strip()
              except subprocess.CalledProcessError as e:
                  print(f"Error running command: {cmd}")
                  print(f"Error: {e.stderr}")
                  return None



          def get_issue_task_list_items(repo_owner, repo_name, issue_number):
              """Get task list items from an issue using GitHub API"""
              task_items = []
              try:
                  # Get the issue body
                  cmd = f'gh api repos/{repo_owner}/{repo_name}/issues/{issue_number}'
                  result = run_gh_command(cmd)
                  if result:
                      issue_data = json.loads(result)
                      body = issue_data.get('body', '')
                      
                      print(f"    Analyzing issue body for task lists:")
                      print(f"    Body content: {repr(body[:200])}...")
                      
                      # Parse task list items with issue references - simplified patterns
                      import re
                      
                      # Pattern 1: - [ ] #123 or - [x] #123 (same repo)
                      same_repo_pattern = r'- \[[ x]\] [^#]*#(\d+)'
                      same_repo_matches = re.findall(same_repo_pattern, body, re.MULTILINE | re.IGNORECASE)
                      print(f"    Same repo pattern matches: {same_repo_matches}")
                      
                      for issue_num in same_repo_matches:
                          task_items.append(f"{repo_owner}/{repo_name}#{issue_num}")
                          print(f"      → Same repo task: {repo_owner}/{repo_name}#{issue_num}")
                      
                      # Pattern 2: - [ ] owner/repo#123 (cross repo)
                      cross_repo_pattern = r'- \[[ x]\] [^#]*([a-zA-Z0-9\-_]+/[a-zA-Z0-9\-_]+)#(\d+)'
                      cross_repo_matches = re.findall(cross_repo_pattern, body, re.MULTILINE | re.IGNORECASE)
                      print(f"    Cross repo pattern matches: {cross_repo_matches}")
                      
                      for repo_ref, issue_num in cross_repo_matches:
                          task_items.append(f"{repo_ref}#{issue_num}")
                          print(f"      → Cross repo task: {repo_ref}#{issue_num}")
                      
                      # Remove duplicates
                      task_items = list(set(task_items))
                      
                      print(f"    Total unique task list items: {len(task_items)}")
                      for item in task_items:
                          print(f"      Final task item: {item}")
                          
              except Exception as e:
                  print(f"    Error parsing task list for {repo_owner}/{repo_name}#{issue_number}: {e}")
                  import traceback
                  traceback.print_exc()
              
              return task_items

          def get_github_issue_connections(repo_owner, repo_name, issue_number):
              """Get GitHub native issue connections using timeline API"""
              connections = []
              try:
                # Get issue timeline to find connected/disconnected events
                # Include preview headers in case sub-issue events require them
                cmd = f'gh api repos/{repo_owner}/{repo_name}/issues/{issue_number}/timeline -H "Accept: application/vnd.github+json"'
                result = run_gh_command(cmd)
                if result:
                  timeline = json.loads(result)
                  for event in timeline:
                    if event.get('event') == 'connected':
                      if 'subject' in event and event['subject'].get('type') == 'issue':
                        subject = event['subject']
                        conn_repo = subject.get('repository', {}).get('full_name', f"{repo_owner}/{repo_name}")
                        conn_number = subject.get('number')
                        if conn_repo and conn_number:
                          connections.append(f"{conn_repo}#{conn_number}")
                          print(f"    GitHub connection: {conn_repo}#{conn_number}")
                  print(f"    Found {len(connections)} GitHub native connections")
              except Exception as e:
                  print(f"    Error getting connections for {repo_owner}/{repo_name}#{issue_number}: {e}")
              
              return connections

          def get_tracked_issues(repo_owner, repo_name, issue_number):
              """Use GraphQL API to retrieve issues tracked BY this issue (children)."""
              tracked = []
              try:
                  # Build GraphQL query with escaped braces to avoid f-string parsing issues
                  query = '''
                  query {{
                    repository(owner: "{repo_owner}", name: "{repo_name}") {{
                      issue(number: {issue_number}) {{
                        trackedIssues(first: 100) {{
                          nodes {{
                            number
                            title
                            repository {{ owner {{ login }} name }}
                          }}
                        }}
                        tracks(first: 100) {{
                          nodes {{
                            number
                            title
                            repository {{ owner {{ login }} name }}
                          }}
                        }}
                      }}
                    }}
                  }}
                  '''.format(repo_owner=repo_owner, repo_name=repo_name, issue_number=issue_number)
                  cmd = f"gh api graphql -f query='{query}'"
                  result = run_gh_command(cmd)
                  if result:
                      data = json.loads(result)
                      issue_data = data.get('data', {}).get('repository', {}).get('issue', {})
                      children = issue_data.get('trackedIssues', {}).get('nodes', [])
                      for child in children:
                          owner = child['repository']['owner']['login']
                          name = child['repository']['name']
                          num = child['number']
                          ref = f"{owner}/{name}#{num}"
                          tracked.append(ref)
                          print(f"    GraphQL tracked issue (child): {ref}")
                      # 'tracks' are parents this issue is tracked by; useful for reverse validation
                      parents = issue_data.get('tracks', {}).get('nodes', [])
                      for parent in parents:
                          owner = parent['repository']['owner']['login']
                          name = parent['repository']['name']
                          num = parent['number']
                          ref = f"{owner}/{name}#{num}"
                          print(f"    GraphQL parent (tracks): {ref}")
                  else:
                      print("    No GraphQL tracked issues data returned")
              except Exception as e:
                  print(f"    Error querying tracked issues (GraphQL) for {repo_owner}/{repo_name}#{issue_number}: {e}")
              return tracked

          def get_iteration_for_item(item):
              """Get the current iteration for a project item"""
              field_values = item.get('fieldValues', {}).get('nodes', [])
              for field_value in field_values:
                  if 'iterationId' in field_value:
                      return {
                          'id': field_value.get('iterationId'),
                          'title': field_value.get('title')
                      }
              return None

          def update_item_iteration(project_id, item_id, field_id, iteration_id):
              """Update an item's iteration in the project"""
              mutation = '''
              mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $iterationId: String) {
                updateProjectV2ItemFieldValue(
                  input: {
                    projectId: $projectId
                    itemId: $itemId
                    fieldId: $fieldId
                    value: {
                      iterationId: $iterationId
                    }
                  }
                ) {
                  projectV2Item {
                    id
                  }
                }
              }
              '''
              
              cmd = f'''gh api graphql -f query='{mutation}' -f projectId={project_id} -f itemId={item_id} -f fieldId={field_id} -f iterationId={iteration_id}'''
              return run_gh_command(cmd)

          # Load project data
          print("Loading project data...")
          with open('project_items.json', 'r') as f:
              project_data = json.load(f)

          items = project_data['data']['node']['items']['nodes']
          project_id = os.environ['PROJECT_ID']
          iteration_field_id = os.environ['ITERATION_FIELD_ID']
          
          print(f"Project ID: {project_id}")
          print(f"Iteration Field ID: {iteration_field_id}")
          print(f"Total items in project: {len(items)}")

          # Debug: Print first few items to understand structure
          print("\n=== DEBUG: First 3 items structure ===")
          for i, item in enumerate(items[:3]):
              print(f"Item {i+1}:")
              content = item.get('content')
              if content:
                  print(f"  Issue #{content.get('number', 'N/A')}: {content.get('title', 'No title')[:50]}...")
                  repo = content.get('repository', {})
                  print(f"  Repository: {repo.get('owner', {}).get('login', 'N/A')}/{repo.get('name', 'N/A')}")
              else:
                  print("  No content (not an issue)")
              
              iteration = get_iteration_for_item(item)
              print(f"  Current iteration: {iteration.get('title') if iteration else 'None'}")
              print()

          # Build a map of issues by repository and number
          issue_map = {}
          issues_with_iterations = 0
          issues_without_iterations = 0
          
          for item in items:
              content = item.get('content')
              if content and content.get('number'):
                  repo_info = content['repository']
                  repo_key = f"{repo_info['owner']['login']}/{repo_info['name']}"
                  issue_number = content['number']
                  
                  if repo_key not in issue_map:
                      issue_map[repo_key] = {}
                  
                  iteration = get_iteration_for_item(item)
                  if iteration and iteration.get('id'):
                      issues_with_iterations += 1
                  else:
                      issues_without_iterations += 1
                  
                  issue_map[repo_key][issue_number] = {
                      'item': item,
                      'content': content,
                      'iteration': iteration
                  }

          print(f"\n=== PROJECT SUMMARY ===")
          print(f"Total repositories: {len(issue_map)}")
          print(f"Issues with iterations: {issues_with_iterations}")
          print(f"Issues without iterations: {issues_without_iterations}")
          
          for repo_key, repo_issues in issue_map.items():
              print(f"  {repo_key}: {len(repo_issues)} issues")

          # Find parent-child relationships and sync iterations
          print(f"\n=== ANALYZING RELATIONSHIPS ===")
          updates_made = 0
          potential_parents = 0
          relationships_found = 0
          
          for repo_key, repo_issues in issue_map.items():
              for issue_number, issue_data in repo_issues.items():
                  content = issue_data['content']
                  parent_iteration = issue_data['iteration']
                  
                  print(f"\nAnalyzing {repo_key}#{issue_number}: {content.get('title', 'No title')[:50]}...")
                  
                  if not parent_iteration or not parent_iteration.get('id'):
                      print(f"  Skipping - no iteration set")
                      continue
                  
                  potential_parents += 1
                  print(f"  Parent iteration: {parent_iteration.get('title')}")
                  
                  # Get repository details
                  repo_info = content['repository']
                  repo_owner = repo_info['owner']['login']
                  repo_name = repo_info['name']
                  
                  # Find child issues using GitHub native methods
                  print(f"  Checking GitHub native issue connections...")
                  github_connections = get_github_issue_connections(repo_owner, repo_name, issue_number)
                  
                  print(f"  Checking task list items...")
                  task_list_items = get_issue_task_list_items(repo_owner, repo_name, issue_number)

                  print(f"  Checking GraphQL tracked issues (sub-issues)...")
                  graphql_tracked = get_tracked_issues(repo_owner, repo_name, issue_number)
                  
                  # Combine all child references
                  all_child_refs = []
                  all_child_refs.extend(github_connections)
                  all_child_refs.extend(task_list_items)
                  all_child_refs.extend(graphql_tracked)
                  
                  # Remove duplicates
                  child_refs = list(set(all_child_refs))
                  
                  if not child_refs:
                      print(f"  No child references found via GitHub native methods")
                      continue
                  
                  relationships_found += len(child_refs)
                  print(f"  Found {len(child_refs)} child references:")
                  print(f"    - GitHub connections (timeline): {len(github_connections)}")
                  print(f"    - Task list items (parsed): {len(task_list_items)}")
                  print(f"    - GraphQL trackedIssues: {len(graphql_tracked)}")
                  
                  for child_ref in child_refs:
                      # Parse child reference (format: "owner/repo#123")
                      if '#' in child_ref:
                          repo_part, number_part = child_ref.split('#', 1)
                          child_repo = repo_part
                          try:
                              child_number = int(number_part)
                          except ValueError:
                              print(f"    Invalid issue number in {child_ref}")
                              continue
                      else:
                          print(f"    Invalid child reference format: {child_ref}")
                          continue
                      
                      print(f"    Checking child: {child_repo}#{child_number}")
                      
                      # Check if child issue exists in our project
                      if child_repo in issue_map and child_number in issue_map[child_repo]:
                          child_data = issue_map[child_repo][child_number]
                          child_iteration = child_data['iteration']
                          
                          print(f"      Child found in project!")
                          print(f"      Child current iteration: {child_iteration.get('title') if child_iteration else 'None'}")
                          print(f"      Parent iteration: {parent_iteration.get('title')}")
                          
                          # If child iteration is different from parent, update it
                          if not child_iteration or child_iteration.get('id') != parent_iteration.get('id'):
                              print(f"      → NEEDS UPDATE!")
                              print(f"Syncing iteration for {child_repo}#{child_number}")
                              print(f"  From: {child_iteration.get('title', 'None') if child_iteration else 'None'}")
                              print(f"  To: {parent_iteration.get('title')}")
                              
                              result = update_item_iteration(
                                  project_id,
                                  child_data['item']['id'],
                                  iteration_field_id,
                                  parent_iteration['id']
                              )
                              
                              if result:
                                  updates_made += 1
                                  print(f"  ✓ Updated successfully")
                              else:
                                  print(f"  ✗ Update failed")
                          else:
                              print(f"      → Already in sync")
                      else:
                          print(f"      Child not found in project")

          print(f"\n=== FINAL SUMMARY ===")
          print(f"Potential parent issues: {potential_parents}")
          print(f"Relationships found: {relationships_found}")
          print(f"Total updates made: {updates_made}")
          print("NOTE: If relationships are missing, ensure the 'tracked issues' feature is enabled and the workflow token has sufficient repo+issues scope. Also confirm sub-issues are created via GitHub's native UI (Tracks / Tracked by).")
          EOF

          # Run the synchronization script
          python3 sync_script.py

      - name: Check for recent iteration changes (if available)
        env:
          GH_TOKEN: ${{ secrets.TEST }}
        run: |
          echo "=== CHECKING FOR RECENT CHANGES ==="
          if [ "${{ github.event_name }}" = "issues" ]; then
            echo "Triggered by issue event - Issue #${{ github.event.issue.number }}"
            echo "Action: ${{ github.event.action }}"
          else
            echo "Triggered by schedule or manual dispatch"
          fi
          
          # List recent issues to see what we're working with
          echo "Recent issues in repositories:"
          gh search issues --owner AquaTechOrg --limit 5 --sort updated --json number,title,repository,updatedAt
          
      - name: Provide relationship setup instructions
        env:
          GH_TOKEN: ${{ secrets.TEST }}
        run: |
          echo "=== HOW TO ESTABLISH CROSS-REPOSITORY RELATIONSHIPS ==="
          echo ""
          echo "This workflow now operates ORGANIZATION-WIDE across ALL repositories!"
          echo ""
          echo "METHOD 1: GitHub Native Tracking (Recommended)"
          echo "1. Go to any parent issue (with iteration set)"
          echo "2. In the right sidebar, look for 'Tracked by' or 'Tracks' section"
          echo "3. Click 'Add tracked issue' and select issues from ANY repo"
          echo "4. Both same-repo and cross-repo tracking supported"
          echo ""
          echo "METHOD 2: Cross-Repository Text References"
          echo "1. Edit parent issue description to include:"
          echo "   Same repo:     'Sub-tasks: #123'"
          echo "   Cross repo:    'Sub-tasks: owner/repo-name#456'"
          echo "   Task list:     '- [ ] owner/other-repo#789'"
          echo "   Epic format:   'Epic includes: #123, owner/repo#456'"
          echo ""
          echo "METHOD 3: GitHub CLI Examples"
          echo "gh issue edit 1 --repo AquaTechOrg/main-repo --body 'Epic includes: #2, AquaTechOrg/backend#45'"
          echo ""
          echo "METHOD 4: Automatic Discovery"
          echo "- The workflow automatically finds all repos in AquaTechOrg"
          echo "- Issues from ANY repository can be parents/children"
          echo "- Cross-repository iteration sync is fully supported"
          echo ""
          echo "EXAMPLES OF VALID REFERENCES:"
          echo "- #123 (same repository)"
          echo "- AquaTechOrg/backend#456 (specific repository)"
          echo "- AquaTechOrg/frontend#789 (another repository)"
          echo "- owner/any-repo#999 (any repository)"

      - name: Provide GitHub native setup instructions
        run: |
          echo "=== GITHUB NATIVE SUB-ISSUE SETUP ==="
          echo ""
          echo "This workflow uses GitHub's NATIVE sub-issue functionality:"
          echo ""
          echo "METHOD 1: Task Lists (Recommended)"
          echo "1. Edit the parent issue (Issue #1)"
          echo "2. Add task list items with issue references:"
          echo "   - [ ] #2 Sub-task description"
          echo "   - [ ] #3 Another sub-task"
          echo "   - [x] #4 Completed sub-task"
          echo "3. GitHub automatically creates relationships"
          echo ""
          echo "METHOD 2: Issue Connections (Beta)"
          echo "1. Go to an issue page"
          echo "2. Look for 'Development' or 'Sub-issues' section"
          echo "3. Use 'Connect issue' or 'Add sub-issue' buttons"
          echo ""
          echo "METHOD 3: Cross-Repository Task Lists"
          echo "   - [ ] AquaTechOrg/backend#123 Backend task"
          echo "   - [ ] AquaTechOrg/frontend#456 Frontend task"
          echo ""
          echo "CURRENT SITUATION:"
          echo "- Issue #1: Has iteration 'Iteration 2'"
          echo "- Issue #2: No iteration (will inherit)"
          echo "- Add '- [ ] #2 Sub-task' to Issue #1 description"

      - name: Log synchronization results
        run: |
          echo "Iteration synchronization completed at $(date)"
          echo "Uses GitHub native sub-issue detection (task lists + issue connections)"
          echo ""
          echo "To establish relationships: Add task list items like '- [ ] #2' to parent issues"
          echo ""
          echo "If 'Total updates made: 0', follow the relationship setup instructions above."

